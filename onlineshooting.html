<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball with Speed Control</title>
</head>
<style>
    canvas {
        border: 1px solid black;
    }
</style>

<body>

    <canvas id="gameCanvas" width="1000" height="300"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let massUser = 1000
        let massBall = 200
        let x = canvas.width / 2;
        let y = canvas.height / 2;
        let ux = canvas.width / 2;
        let uy = canvas.height - 60;
        let dx = 2; // Horizontal velocity of the blue ball
        let dy = -2; // Vertical velocity of the blue ball
        let speed = 0;
        let userSpeed = 0 // Initial speed of the user (black ball)
        let rotationAngle = 0; // User's rotation angle
        let keysPressed = {}; // Tracks which keys are pressed

        function drawUserBall(x, y, size, rotationAngle) {
            // Save the current state of the canvas
            ctx.save();

            // Translate to the ball's location
            ctx.translate(x, y);
            // Rotate the canvas by the specified rotation angle
            ctx.rotate(rotationAngle * Math.PI / 180);

            // Draw the left half (black)
            ctx.beginPath();
            ctx.arc(0, 0, size, 0.5 * Math.PI, 1.5 * Math.PI, false);
            ctx.lineTo(0, -size); // Line back to the starting point
            ctx.fillStyle = 'black';
            ctx.fill();

        

            // Draw the right half (blue)
            ctx.beginPath();
            ctx.arc(0, 0, size, -0.5 * Math.PI, 0.5 * Math.PI, false);
            ctx.lineTo(0, size); // Line back to the starting point
            ctx.fillStyle = '#0095DD'; // Blue color
            ctx.fill();

            // Restore the saved state of the canvas
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBall(x, y, "#0095DD", 10); // Draw blue ball
            drawUserBall(ux, uy, 20, rotationAngle); // Draw black ball (user)

            checkCollision(); // Check for collision and respond

            // Update blue ball position
            speed = Math.min(Math.max(speed, 0), 10)
            speed = speed > 0 ? (speed - 0.02) : speed < 0 ? Math.floor(speed + 0.2) : Math.floor(speed)
            if (x + dx * speed > canvas.width - 10 || x + dx * speed < 10) {
                dx = -dx;
            }
            if (y + dy * speed < 10 || y + dy * speed > canvas.height - 10) {
                dy = -dy;
            }
            x += dx * speed;
            y += dy * speed;

            updatePosition(); // Update user (black ball) position
            requestAnimationFrame(draw);
        }

        function drawBall(x, y, color, size) {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
        }

        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
            if (e.key === "m") {
                speed = 0.1;
            } else if (e.key === "n") {
                speed = Math.max(0.1, speed - 0.1);
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        function updatePosition() {
            if (keysPressed['ArrowLeft']) rotationAngle -= 5;
            if (keysPressed['ArrowRight']) rotationAngle += 5;
            if (keysPressed['ArrowUp']) {
                userSpeed = userSpeed <= 5 ? userSpeed + 0.4 : userSpeed
                let rad = rotationAngle * Math.PI / 180;
                ux += Math.cos(rad) * userSpeed;
                uy += Math.sin(rad) * userSpeed;
            }

            if (!keysPressed['ArrowUp'] && Math.floor(userSpeed) >= 0) {
                userSpeed = userSpeed - 0.1
                let rad = rotationAngle * Math.PI / 180;
                ux += Math.cos(rad) * userSpeed;
                uy += Math.sin(rad) * userSpeed;
            }

            // Ensure the black ball stays within canvas bounds
            ux = Math.max(10, Math.min(canvas.width - 10, ux));
            uy = Math.max(10, Math.min(canvas.height - 10, uy));
        }

        function checkCollision() {
            let dxi = x - ux;
            let dyi = y - uy;
            let distance = Math.sqrt(dxi * dxi + dyi * dyi);

            if (distance < 30) { // Adjusted for the size of the black ball
                // Calculate relative velocity components
                let vectorToBlueBall = { x: dx, y: dy };
                let userDirection = {
            x: Math.cos(rotationAngle * Math.PI / 180),
            y: Math.sin(rotationAngle * Math.PI / 180)
        };

        // Dot product to determine if the blue ball is in front of the user ball
        let dotProduct = vectorToBlueBall.x * userDirection.x + vectorToBlueBall.y * userDirection.y;


                // let relativeVx = (dx * speed - Math.cos(rotationAngle * Math.PI / 180) * userSpeed )* 0.5;
                // let relativeVy = (dy * speed - Math.sin(rotationAngle * Math.PI / 180) * userSpeed)*0.5;
                let relativeVx = (((massUser * Math.cos(rotationAngle * Math.PI / 180) * userSpeed) + (speed * massBall * Math.cos(rotationAngle * Math.PI / 180)))/massBall)*0.5
                let relativeVy = (((massUser * Math.sin(rotationAngle * Math.PI / 180) * userSpeed) + (speed * massBall * Math.sin(rotationAngle * Math.PI / 180)))/massBall)*0.5

                // Calculate magnitude of the relative velocity (impact speed)
                let impactSpeed = Math.sqrt(relativeVx * relativeVx + relativeVy * relativeVy);
                // Update the speed of the blue ball based on the impact speed
                speed = dotProduct < 0? impactSpeed : speed; // You can adjust the division factor to your liking

                // Reverse the direction of the blue ball
                dx = -dx;
                dy = -dy;

                // Move the blue ball out of collision
                x += dx * speed;
                y += dy * speed;
            }
        }

        draw();
    </script>
</body>

</html>